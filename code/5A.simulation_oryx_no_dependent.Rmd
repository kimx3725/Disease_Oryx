---
title: "6.simulation_5x5states"
author: "Dennis Kim"
date: "2024-01-30"
output: html_document
---

# Document Preamble 
```{r preamble, message=FALSE, warning=FALSE}
# load libraries
library(knitr)
library(readr)
library(data.table)
library(here)
library(purrr)
library(lubridate)
library(scales)
library(conflicted)
library(tidyverse)
library(scico)
library(patchwork)
library(tictoc)

# call environmental data
library(terra)
library(sf)

# analysis
library(amt)
library(MASS)
library(statip)
library(ConnMatTools)

# visualization 
library(ggplot2)
library(tidyterra)

options(width = 150)

conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflicts_prefer(lubridate::hour)
conflicts_prefer(terra::plot)
conflicts_prefer(dplyr::lag)
```

# shrub layers
```{r shrub layer}
# observed shrub cover
shrub <- terra::rast("D:/Oryx/data/env_data/shrub/cropped_shrub.tif")

#plot(shrub)
```

# simulating tracks using the amt functions 

1. specifying paamters governing the movements for the individual using the *make_issf_model()** function 
2. specifying a redistribution kernel for generating movements based on an initial location and bearing 
3. generating paths from the simulated redistribution kernel specified for a user-provided number of steps 

First call the real dataset to see the reasonable initial values for parameter values per group
```{r observed dataset}
hmm <- readr::read_rds(here::here("data/HMM_outputs", "hmm_m2_output.rds"))

# extracting step lenght and turn angle distribution per each state 

# step length
meanNE <- hmm$mle$step[1,1]
sdNE <- hmm$mle$step[2,1]

meanNR <- hmm$mle$step[1,2]
sdNR <- hmm$mle$step[2,2]  

meanIE <- hmm$mle$step[1,3]
sdIE <- hmm$mle$step[2,3]  

meanIR <- hmm$mle$step[1,4] 
sdIR <- hmm$mle$step[2,4]

meanD <- hmm$mle$step[1,5]
sdD <- hmm$mle$step[2,5]

# Use gammaParamsConvert function to calculate shape and scale parameters
NE_params <- gammaParamsConvert(mean = meanNE, sd = sdNE)
NR_params <- gammaParamsConvert(mean = meanNR, sd = sdNR)
IE_params <- gammaParamsConvert(mean = meanIE, sd = sdIE)
IR_params <- gammaParamsConvert(mean = meanIR, sd = sdIR)
D_params <- gammaParamsConvert(mean = meanD, sd = sdD)

hmm$mle$angle
NE_params
NR_params
IR_params
D_params
```

prep for the simulation 
```{r prep for the simulation}
# covariance matrix for the movement parameters 
sig <- matrix(c(0.4, 0.15, 0.15, 0.15, 0.3, 0.15, 0.15, 0.15, 0.4), ncol = 3, byrow = TRUE)

# parameter values
param.value_n <- data.frame(id = NA, shape = NA, scale = NA, kappa = NA) # non_infected 
param.value_i <- data.frame(id = NA, shape = NA, scale = NA, kappa = NA) # infected

# number of individual
n_ind <- 10

# Initial start point
start <- make_start(c(runif(1, 300000, 360000), runif(1, 1600000, 1700000)), ta_ = 0)

# number of total steps to generate = the average time across 40 individuals
total_days <- 28
```


## transitional matrix - infection x behavioral states 

prep for the recursive Markov chain manner for getting the infection & behavioral status (each is per day) and 24 steps per day since it is resampled by hourly. 
```{r tmp status generator}
# Modify the code to use a 4x4 transitional probability matrix and track 4 different states daily.

# Define the transitional probability matrix for infection
trans_m <- matrix(c(
  0.7, 0.3, 0, 0, 0,
  0.2499, 0.5, 0, 0.25, 0.0001,
  0, 0, 0.3, 0.7, 0,
  0, 0, 0.2, 0.5, 0.3,
  0, 0, 0, 0, 1
), nrow = 5, ncol = 5, byrow = TRUE)

# Function: ReMC
# Description: This function represents a recursive representation of a Markov chain.
# Parameters:
#   - v: vector representing the initial state of the Markov chain
#   - n: integer representing the number of steps in the Markov chain
# Returns:
#   - A vector representing the state of the Markov chain after n steps

ReMC <- function(v, n) {
  # Base case: if n equals 1, return the initial state v
  if (n == 1) return(v)
  
  # Recursive step: compute the state of the Markov chain after n - 1 steps
  p <- ReMC(v, n - 1)
  
  # Extract the last element of the computed state vector
  u <- tail(p, 1)
  
  # Select the next state based on the transition matrix trans_m
  # Sample from a vector of states with probabilities determined by the transition matrix
  next_state <- sample(1:5, 1, prob = trans_m[u, ])
  
  # Concatenate the computed state vector with the next state
  # This represents the state of the Markov chain after n steps
  c(p, next_state)
}

# Define the initial state value - starting from the non-infected explore phase  
x0 <- c(state = 1)  # Assuming the initial state is 1 (non-infected explore)

# Generate unique state_info for each individual
state_info <- matrix(NA, nrow = n_ind, ncol = total_days)
for (ind in 1:n_ind) {
  state_info[ind, ] <- sapply(x0, ReMC, total_days)
}

state_info

# Display the state information
#print(state_info)

# save the state info per id 
#saveRDS(state_info, "sim_state_info_id1_28days.rds")
```


## simulate the paths

The provided code simulates the path of an individual with specified conditions and annotations. It incorporates a transitional probability matrix (tpm) to determine changes in infection status during each step of the simulation. Depending on the current infection status of the individual, the code selects the appropriate probability from the matrix to determine the next state. The simulation iterates through each step, updating the infection status accordingly and simulating the path based on the redistribution kernel.
```{r simulation}
# Create empty lists to store results
ssf_sim <- vector("list", length = total_days)
ind_sim <- vector("list", length = n_ind)

# Looping for transitions between states
for (ind in 1:n_ind) {
  
  # Model per group
  
  ## model 1 - non-infected & exploratory
  m_ne <- make_issf_model(coefs = c("final.shrub_end" = 0.005, 
                                    "sl_" = 0, 
                                    "log(sl_)" = 0, 
                                    "cos(ta_)" = 0, 
                                    "sl_:final.shrub_start" = 0.005, 
                                    "log(sl_):final.shrub_start" = 0.005, 
                                    "cos(ta_):final.shrub_start" = 0.005),
                          sl = make_gamma_distr(shape = 3.3,
                                                scale = 597),
                          ta = make_vonmises_distr(kappa = 0.09))
  
  ## model 2 - non infected & resting
  m_nr <- make_issf_model(coefs = c("final.shrub_end" = 0.01, 
                                    "sl_" = 0, 
                                    "log(sl_)" = 0, 
                                    "cos(ta_)" = 0, 
                                    "sl_:final.shrub_start" = 0.01, 
                                    "log(sl_):final.shrub_start" = 0.01, 
                                    "cos(ta_):final.shrub_start" = 0.01),
                          sl = make_gamma_distr(shape = 0.5,
                                                scale = 558),
                          ta = make_vonmises_distr(kappa = 0.0001))
  
  ## model 3 - infected & exploratory
  m_ie <- make_issf_model(coefs = c("final.shrub_end" = 0.002, 
                                    "sl_" = 0, 
                                    "log(sl_)" = 0, 
                                    "cos(ta_)" = 0, 
                                    "sl_:final.shrub_start" = 0.002, 
                                    "log(sl_):final.shrub_start" = 0.002, 
                                    "cos(ta_):final.shrub_start" = 0.002),
                          sl = make_gamma_distr(shape = 0.7,
                                                scale = 449),
                          ta = make_vonmises_distr(kappa = 0.06))
  
  ## model 4 - infected & resting
  m_ir <- make_issf_model(coefs = c("final.shrub_end" = 0.03, 
                                    "sl_" = 0, 
                                    "log(sl_)" = 0, 
                                    "cos(ta_)" = 0, 
                                    "sl_:final.shrub_start" = 0.03, 
                                    "log(sl_):final.shrub_start" = 0.03, 
                                    "cos(ta_):final.shrub_start" = 0.03),
                          sl = make_gamma_distr(shape = 0.5,
                                                scale = 558),
                          ta = make_vonmises_distr(kappa = 0.0001))
  
  ## model 5 - death 
  m_d <- make_issf_model(coefs = c("final.shrub_end" = 0, 
                                    "sl_" = 0, 
                                    "log(sl_)" = 0, 
                                    "cos(ta_)" = 0, 
                                    "sl_:final.shrub_start" = 0, 
                                    "log(sl_):final.shrub_start" = 0, 
                                    "cos(ta_):final.shrub_start" = 0),
                          sl = make_gamma_distr(shape = 0.76,
                                                scale = 16.24),
                          ta = make_vonmises_distr(kappa =0.001))

  # Redistribution kernel per group
  
  ## redistribution kernel - non-infected explore
  rdk_ne <- redistribution_kernel(m_ne, 
                                  start = start, 
                                  map = shrub, 
                                  landscape = "continuous", 
                                  tolerance = 0.02)
  
  ## redistribution kernel - non-infected resting
  rdk_nr <- redistribution_kernel(m_nr, 
                                  start = start, 
                                  map = shrub, 
                                  landscape = "continuous", 
                                  tolerance = 0.02)
  
  ## redistribution kernel - infected exploratory
  rdk_ie <- redistribution_kernel(m_ie, 
                                  start = start, 
                                  map = shrub, 
                                  landscape = "continuous", 
                                  tolerance = 0.02)
  
  ## redistribution kernel - infected resting
  rdk_ir <- redistribution_kernel(m_ir, 
                                  start = start, 
                                  map = shrub, 
                                  landscape = "continuous", 
                                  tolerance = 0.02)
  
  ## redistirubtion kernel - death 
  rdk_d <- redistribution_kernel(m_d, 
                                  start = start, 
                                  map = shrub, 
                                  landscape = "continuous", 
                                  tolerance = 0.02)

  # Initialize the start position
  start_position <- start
  
  # Loop for each step
  for (i in 1:total_days) {
    # get the infection status of each day 
    state <- state_info[ind, i]
  
    # IF the daily state is noninfected & explore (1), then generate 24 steps by using rdk_n for 1 step-ahead projections
    if (state == 1) {
      ssf_sim[[i]] <- data.frame(id = ind, 
                                 state = state,
                                 positions = list(simulate_path(rdk_ne, n.steps = 24, custom_start = start_position)))
    } else {
      # IF the daily state is noninfected & resting (2), then generate 24 steps by using rdk_i for 1 step-ahead projections
      if (state == 2) {
        ssf_sim[[i]] <- data.frame(id = ind, 
                                    state = state,
                                    positions = list(simulate_path(rdk_nr, n.steps = 24, custom_start = start_position)))
      } else {
        # IF the daily state is infected & explore (3), then generate 24 steps by using rdk_r for 1 step-ahead projections
        if (state == 3) {
          ssf_sim[[i]] <- data.frame(id = ind, 
                                     state = state,
                                     positions = list(simulate_path(rdk_ie, n.steps = 24, custom_start = start_position)))
        } else {
          # IF the daily state is infected & resting (4), then generate 24 steps by using rdk_e for 1 step-ahead projections
          if (state == 4) {
            ssf_sim[[i]] <- data.frame(id = ind, 
                                       state = state,
                                       positions = list(simulate_path(rdk_ir, n.steps = 24, custom_start = start_position)))
          } else{
            if (state == 5) {
            ssf_sim[[i]] <- data.frame(id = ind, 
                                       state = state,
                                       positions = list(simulate_path(rdk_d, n.steps = 24, custom_start = start_position)))
          }
        }
      }
    }
    # Update the start position for the next iteration
    start_position <- tail(ssf_sim[[i]]$positions, 1)$position
  }
  }
  ind_sim[[ind]] <- ssf_sim
}

# Flatten the nested list
flat_list <- unlist(ind_sim, recursive = FALSE)

# Convert the flattened list to a dataframe
ssf_df <- do.call(rbind, lapply(flat_list, as.data.frame))

#ssf_df <- do.call(rbind, ind_sim)
#ssf_df <- ssf_df[!duplicated(ssf_df$positions.x_, ssf_df$positions.y_),]
ssf_df

#positions.t <- seq(as.POSIXct("2024-02-05 20:27:26"), as.POSIXct("2024-02-26 16:27:26"), by="hour")
#ssf_df$positions.t_ <- positions.t

#ssf_df <- ssf_df %>% mutate(postions.t_ = row_number())
#ssf_df %>% distinct(id)

# save the data
saveRDS(ssf_df, "sim_trk_10ids_3.rds")
```

# Visualizations

visualization of the tracks:
```{r trk visualization}
# prep for sff_df
ssf_df$state <- as.factor(ssf_df$state)

# change the labels
state_names <- c('1' = "NE", '2' = "NR", '3' = "IE", '4' = "IR", '5' = "D")

ggplot()+
  geom_point(data = ssf_df, aes(positions.x_, positions.y_))+
  facet_wrap(~state, 
             nrow = 1,
             labeller = labeller(state = state_names))


# visualize the movement paths across behaviors
p <- ggplot()+
  geom_spatraster(data = shrub, show.legend = FALSE)+
  geom_point(data = ssf_df, aes(positions.x_, positions.y_), size = 0.7)+
  labs(title = "Oryx simulation with 5 different states")+
  facet_wrap(~state,
             labeller = labeller(state = state_names),
             nrow = 1)+
  scale_fill_terrain_c()+
  theme_bw()+
  xlab("Eastings")+
  ylab("Northings")

p + theme(axis.text.x=element_text(angle=45, hjust=1))
```

# Footer
```{r footer}
sessionInfo()
```