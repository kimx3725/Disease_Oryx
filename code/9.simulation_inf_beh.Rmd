---
title: "8.simulations_observed"
author: "Dennis Kim"
date: "2024-01-30"
output: html_document
---

# Document Preamble 
```{r preamble, message=FALSE, warning=FALSE}
# load libraries
library(knitr)
library(readr)
library(data.table)
library(here)
library(purrr)
library(lubridate)
library(scales)
library(conflicted)
library(tidyverse)
library(scico)
library(patchwork)
library(tictoc)

# call environmental data
library(terra)
library(sf)

# analysis
library(amt)
library(MASS)
library(statip)

# visualization 
library(ggplot2)
library(tidyterra)

options(width = 150)

conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflicts_prefer(lubridate::hour)
conflicts_prefer(terra::plot)
conflicts_prefer(dplyr::lag)
```

# shrub layers
```{r shrub layer}
# observed shrub cover
shrub <- terra::rast("D:/Oryx/data/env_data/shrub/cropped_shrub.tif")

plot(shrub)
shrub
```

# simulating tracks using the amt functions 

1. specifying paamters governing the movements for the individual using the *make_issf_model()** function 
2. specifying a redistribution kernel for generating movements based on an initial location and bearing 
3. generating paths from the simulated redistribution kernel specified for a user-provided number of steps 

First call the real dataset to see the reasonable initial values for parameter values per group
```{r observed dataset}
#n_oryx <- read_rds(here::here("data/ssf_data", "n_ssf_oryx.rds"))
#u_oryx <- read_rds(here::here("data/ssf_data", "u_ssf_oryx.rds"))
#i_oryx <- read_rds(here::here("data/ssf_data", "i_ssf_oryx.rds"))

#unique(n_oryx$ID) %>% length() # 19 individuals
#unique(u_oryx$ID) %>% length() # 25 individuals
#unique(i_oryx$ID) %>% length() # 4 individuals
```

fit distribution to the dataset per infection and non-infection status and get the tentative movement paramters for the simulation.
```{r tentative params}
# tentative paramters for non infected individuals 

# non-infected individuals
#sl_dist_ninf <- fit_distr(n_oryx$sl_, "gamma") # step length
#ta_dist_ninf <- fit_distr(n_oryx$ta_, "vonmises") # turn angle

# infected individuals
#sl_dist_inf <- fit_distr(i_oryx$sl_, "gamma") # step length
#ta_dist_inf <- fit_distr(i_oryx$ta_, "vonmises") # turn angle
```

visualize the movement parameter distribution per each state
```{r vis movement params}
# gamma distribution

## data for plotting
plot_sl <- data.frame(x = rep(NA, 100))

## x-axis is sequence of possible step lengths
plot_sl$x <- seq(from = 0, to = 2500, length.out = 100)

# y-axis is the prob density under the given gamma distribution 

## non-infected resting 
plot_sl$ni_r <- dgamma(
  x = plot_sl_i$x,
  shape = 0.3,
  scale = 600
)

# noninfected exploratory
plot_sl$ni_e <- dgamma(
  x = plot_sl_i$x,
  shape = 0.7,
  scale = 1200
)

# infected exploratory
plot_sl$i_e <- dgamma(
  x = plot_sl_i$x,
  shape = 0.5,
  scale = 900
)

# infected resting
plot_sl$i_r <- dgamma(
  x = plot_sl_i$x,
  shape = 0.1,
  scale = 800
)

# pivot from wide data to long data
plot_sl <- plot_sl %>% pivot_longer(cols = -x)
plot_sl


# plot 
ggplot(plot_sl, aes(x = x, y = value, color = factor(name)))+
  geom_line(size = 1)+
  xlab("Step Length (m)")+
  ylab("Probability Density")+
  scale_color_manual(name = "Distribution",
                     breaks = c("ni_r", "ni_e", "i_r", "i_e"),
                     values = c("blue", "orange", "red", "darkgreen"))+
  theme_bw()
```

prep for the simulation 
```{r prep for the simulation}
# covariance matrix for the movement parameters 
sig <- matrix(c(0.4, 0.15, 0.15, 0.15, 0.3, 0.15, 0.15, 0.15, 0.4), ncol = 3, byrow = TRUE)

# parameter values
param.value_n <- data.frame(id = NA, shape = NA, scale = NA, kappa = NA) # non_infected 
param.value_i <- data.frame(id = NA, shape = NA, scale = NA, kappa = NA) # infected

# number of individual
n_ind <- 1 

# Initial start point
start <- make_start(c(runif(1, 300000, 360000), runif(1, 1600000, 1700000)), ta_ = 0)

# number of total steps to generate
total_days <- 10
```


## transitional matrix - infection

prep for the recursive Markov chain manner for getting the infection status (each is per day) and 24 steps per day since it is resampled by hourly. 
```{r infection status generator}
# transitional probability matrix for infection
trans_m1 <- matrix(c(0.9, 0.1, 0.01, 0.99),
              nrow = 2,
              byrow = TRUE)

# Function: ReMC
# Description: This function represents a recursive representation of a Markov chain.
# Parameters:
#   - v: vector representing the initial state of the Markov chain
#   - n: integer representing the number of steps in the Markov chain
# Returns:
#   - A vector representing the state of the Markov chain after n steps

ReMC_i <- function(v, n) {
    # Base case: if n equals 1, return the initial state v
    if (n == 1) return(v)
    
    # Recursive step: compute the state of the Markov chain after n - 1 steps
    p <- ReMC_i(v, n - 1)
    
    # Extract the last element of the computed state vector
    u <- tail(p, 1)
    
    # Select the next state based on the transition matrix trans_m
    # Sample from a binary vector (0, 1) with probabilities determined by the transition matrix
    next_state <- sample(c(0, 1), 1, prob = trans_m1[ifelse(u, 2, 1),])
    
    # Concatenate the computed state vector with the next state
    # This represents the state of the Markov chain after n steps
    c(p, next_state)
}

# initial infection value - start from the non-infected phase  
x0 <- c(infection = 0)

# apply the above function to the list of vector of the initial infection parm val
infection_info <- (sapply(x0, ReMC_i, total_days))

# check the infection_info
infection_info
```

## transitional matrix - behavior

same approach as the above codelines
```{r behavior status generator}
# transitional probability matrix for behavioral states
trans_m2 <- matrix(c(0.83, 0.17, 0.1, 0.9),
              nrow = 2,
              byrow = TRUE)

# Function: ReMC
# Description: This function represents a recursive representation of a Markov chain.
# Parameters:
#   - v: vector representing the initial state of the Markov chain
#   - n: integer representing the number of steps in the Markov chain
# Returns:
#   - A vector representing the state of the Markov chain after n steps

ReMC_b <- function(v, n) {
    # Base case: if n equals 1, return the initial state v
    if (n == 1) return(v)
    
    # Recursive step: compute the state of the Markov chain after n - 1 steps
    p <- ReMC_b(v, n - 1)
    
    # Extract the last element of the computed state vector
    u <- tail(p, 1)
    
    # Select the next state based on the transition matrix trans_m
    # Sample from a binary vector (0, 1) with probabilities determined by the transition matrix
    next_state <- sample(c(0, 1), 1, prob = trans_m2[ifelse(u, 2, 1),])
    
    # Concatenate the computed state vector with the next state
    # This represents the state of the Markov chain after n steps
    c(p, next_state)
}

# initial infection value - start from the explanatory 
x0 <- c(behavior = 1)

# apply the above function to the list of vector of the initial infection parm val
behavior_info <- (sapply(x0, ReMC_b, total_days))

# check the infection_info
behavior_info
```


## simulate the paths

The provided code simulates the path of an individual with specified conditions and annotations. It incorporates a transitional probability matrix (tpm) to determine changes in infection status during each step of the simulation. Depending on the current infection status of the individual, the code selects the appropriate probability from the matrix to determine the next state. The simulation iterates through each step, updating the infection status accordingly and simulating the path based on the redistribution kernel.
```{r simulation}
# Create empty lists to store results
ssf_sim <- vector("list", length = total_days)

# Looping for transitions between states
for (ind in 1:n_ind) {
  
  # Model per group
  
  ## model 1 - non infected & resting
  m_nr <- make_issf_model(coefs = c("final.shrub_end" = 0.01, 
                                    "sl_" = 0, 
                                    "log(sl_)" = 0, 
                                    "cos(ta_)" = 0, 
                                    "sl_:final.shrub_start" = 0.01, 
                                    "log(sl_):final.shrub_start" = 0.01, 
                                    "cos(ta_):final.shrub_start" = 0.01),
                          sl = make_gamma_distr(shape = 0.3,
                                                scale = 600),
                          ta = make_vonmises_distr(kappa = 0.15))
  
  ## model 2 - non-infected & exploratory
  m_ne <- make_issf_model(coefs = c("final.shrub_end" = 0.005, 
                                    "sl_" = 0, 
                                    "log(sl_)" = 0, 
                                    "cos(ta_)" = 0, 
                                    "sl_:final.shrub_start" = 0.005, 
                                    "log(sl_):final.shrub_start" = 0.005, 
                                    "cos(ta_):final.shrub_start" = 0.005),
                          sl = make_gamma_distr(shape = 0.7,
                                                scale = 1200),
                          ta = make_vonmises_distr(kappa = 0.2))
  
  ## model 3 - infected & resting
  m_ir <- make_issf_model(coefs = c("final.shrub_end" = 0.03, 
                                    "sl_" = 0, 
                                    "log(sl_)" = 0, 
                                    "cos(ta_)" = 0, 
                                    "sl_:final.shrub_start" = 0.03, 
                                    "log(sl_):final.shrub_start" = 0.03, 
                                    "cos(ta_):final.shrub_start" = 0.03),
                          sl = make_gamma_distr(shape = 0.5,
                                                scale = 900),
                          ta = make_vonmises_distr(kappa = 0.1))
  ## model 4 - infected & exploratory
  m_ie <- make_issf_model(coefs = c("final.shrub_end" = 0.002, 
                                    "sl_" = 0, 
                                    "log(sl_)" = 0, 
                                    "cos(ta_)" = 0, 
                                    "sl_:final.shrub_start" = 0.002, 
                                    "log(sl_):final.shrub_start" = 0.002, 
                                    "cos(ta_):final.shrub_start" = 0.002),
                          sl = make_gamma_distr(shape = 0.1,
                                                scale = 800),
                          ta = make_vonmises_distr(kappa = 0.25))

  # Redistribution kernel per group
  
  ## redistribution kernel - non-infected
  rdk_nr <- redistribution_kernel(m_nr, 
                                  start = start, 
                                  map = shrub, 
                                  landscape = "continuous", 
                                  tolerance = 0.02)
  
  ## redistribution kernel - infected
  rdk_ne <- redistribution_kernel(m_ne, 
                                  start = start, 
                                  map = shrub, 
                                  landscape = "continuous", 
                                  tolerance = 0.02)
  
  ## redistribution kernel - resting
  rdk_ir <- redistribution_kernel(m_ir, 
                                  start = start, 
                                  map = shrub, 
                                  landscape = "continuous", 
                                  tolerance = 0.02)
  
  ## redistribution kernel - exploratory
  rdk_ie <- redistribution_kernel(m_ie, 
                                  start = start, 
                                  map = shrub, 
                                  landscape = "continuous", 
                                  tolerance = 0.02)

  # Initialize the start position
  start_position <- start
  
  # Loop for each step
  for (i in 1:total_days) {
    # get the infection status of each day 
    infection <- infection_info[i]
    
    # get the behavior status of each day 
    behavior <- behavior_info[i]
  
    # IF the daily infection status = 0 (non-infected) & behavior = 0 (resting), then generate 24 steps by using rdk_n for 1 step-ahead projections
    if (infection == 0 && behavior == 0) {
      ssf_sim[[i]] <- data.frame(id = ind, 
                                  infection = infection,
                                  behavior = behavior,
                                  positions = list(simulate_path(rdk_nr, n.steps = 24, custom_start = start_position)))
    } else {
      # IF the daily infection status = 0 (non-infected) & behavior = 1 (exploratory), then generate 24 steps by using rdk_i for 1 step-ahead projections
      if (infection == 0 && behavior == 1) {
        ssf_sim[[i]] <- data.frame(id = ind, 
                                    infection = infection,
                                    behavior = behavior,
                                    positions = list(simulate_path(rdk_ne, n.steps = 24, custom_start = start_position)))
      } else {
        # IF the daily  infection status = 1 (infected) & behavior = 0 (resting), then generate 24 steps by using rdk_r for 1 step-ahead projections
        if (infection == 1 && behavior == 0) {
          ssf_sim[[i]] <- data.frame(id = ind, 
                                      infection = infection,
                                      behavior = behavior,
                                      positions = list(simulate_path(rdk_ir, n.steps = 24, custom_start = start_position)))
        } else {
          # IF the daily infection status = 1 (infected)& behavior status = 1 (exploratory), then generate 24 steps by using rdk_e for 1 step-ahead projections
          if (infection == 1 && behavior == 1) {
            ssf_sim[[i]] <- data.frame(id = ind, 
                                        infection = infection,
                                        behavior = behavior,
                                        positions = list(simulate_path(rdk_ie, n.steps = 24, custom_start = start_position)))
          }
        }
      }
    }
    # Update the start position for the next iteration
    start_position <- tail(ssf_sim[[i]]$positions, 1)$position
  }
}

# Combine results into one data frame
ssf_df <- do.call(rbind, ssf_sim)
ssf_df <- ssf_df[!duplicated(ssf_df$positions.x_, ssf_df$positions.y_),]

#positions.t <- seq(as.POSIXct("2024-02-05 20:27:26"), as.POSIXct("2024-02-26 16:27:26"), by="hour")
#ssf_df$positions.t_ <- positions.t

#ssf_df <- ssf_df %>% mutate(postions.t_ = row_number())
ssf_df

# save the data
#saveRDS(ssf_df, "ssf_sim_trial1.rds")
```

# Visualizations

visualization of the tracks:
```{r trk visualization}
# prep for sff_df
ssf_df$infection <- as.factor(ssf_df$infection)
ssf_df$behavior <- as.factor(ssf_df$behavior)

# change the labels
infection_names <- c('0' = "Non-infected", '1' = "Infected")
behavior_names <- c('0' = "Resting", '1' = "Exploratory")

ggplot()+
  geom_point(data = ssf_df, aes(positions.x_, positions.y_))+
  facet_wrap(~infection, 
             nrow = 1,
             labeller = labeller(infection = infection_names))

ggplot()+
  geom_point(data = ssf_df, aes(positions.x_, positions.y_))+
  facet_wrap(~behavior, 
             nrow = 1,
             labeller = labeller(behavior = behavior_names))


# visualize the movement paths across behaviors
ggplot() + 
  geom_spatraster(data= shrub, show.legend = FALSE) +
  geom_path(data= ssf_df, aes(positions.x_, positions.y_, color= infection), size = 0.1)+
  #scale_colour_gradient(low = "blue", high ="red")+
  facet_wrap(~behavior, nrow = 1)+
  scale_fill_terrain_c() + theme_bw()

ggplot() + 
  geom_spatraster(data= shrub, show.legend = FALSE) +
  geom_path(data= ssf_df, aes(positions.x_, positions.y_, color= behavior), size = 0.1)+
  #scale_colour_gradient(low = "blue", high ="red")+
  facet_wrap(~infection, nrow = 1)+
  scale_fill_terrain_c() + theme_bw()
```

# Footer
```{r footer}
sessionInfo()
```