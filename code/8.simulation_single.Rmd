---
title: "8.simulations_observed"
author: "Dennis Kim"
date: "2024-01-30"
output: html_document
---

# Document Preamble 
```{r preamble, message=FALSE, warning=FALSE}
# load libraries
library(knitr)
library(readr)
library(data.table)
library(here)
library(purrr)
library(lubridate)
library(scales)
library(conflicted)
library(tidyverse)
library(scico)
library(patchwork)
library(tictoc)

# call environmental data
library(terra)
library(sf)

# analysis
library(amt)
library(MASS)
library(statip)

# visualization 
library(ggplot2)
library(tidyterra)

options(width = 150)

conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflicts_prefer(lubridate::hour)
conflicts_prefer(terra::plot)
conflicts_prefer(dplyr::lag)
```

# shrub layers
```{r shrub layer}
# observed shrub cover
shrub <- terra::rast("D:/Oryx/data/env_data/shrub/cropped_shrub.tif")

plot(shrub)
```

# simulating tracks using the amt functions 

1. specifying paamters governing the movements for the individual using the *make_issf_model()** function 
2. specifying a redistribution kernel for generating movements based on an initial location and bearing 
3. generating paths from the simulated redistribution kernel specified for a user-provided number of steps 

First call the real dataset to see the reasonable initial values for parameter values per group
```{r observed dataset}
#n_oryx <- read_rds(here::here("data/ssf_data", "n_ssf_oryx.rds"))
#u_oryx <- read_rds(here::here("data/ssf_data", "u_ssf_oryx.rds"))
#i_oryx <- read_rds(here::here("data/ssf_data", "i_ssf_oryx.rds"))

#unique(n_oryx$ID) %>% length() # 19 individuals
#unique(u_oryx$ID) %>% length() # 25 individuals
#unique(i_oryx$ID) %>% length() # 4 individuals
```

fit distribution to the dataset per infection and non-infection status and get the tentative movement paramters for the simulation.
```{r tentative params}
# tentative paramters for non infected individuals 

# non-infected individuals
#sl_dist_ninf <- fit_distr(n_oryx$sl_, "gamma") # step length
#ta_dist_ninf <- fit_distr(n_oryx$ta_, "vonmises") # turn angle

# infected individuals
#sl_dist_inf <- fit_distr(i_oryx$sl_, "gamma") # step length
#ta_dist_inf <- fit_distr(i_oryx$ta_, "vonmises") # turn angle
```

visualize the movement parameter distribution per each state
```{r vis movement params}
# gamma distribution

## data for plotting
plot_sl_i <- data.frame(x = rep(NA, 100))

## x-axis is sequence of possible step lengths
plot_sl_i$x <- seq(from = 0, to = 2500, length.out = 100)

# y-axis is the prob density under the given gamma distribution 

## noninfected distribution 
plot_sl_i$ni <- dgamma(
  x = plot_sl_i$x,
  shape = 0.5,
  scale = 1000
)

# infected 
plot_sl_i$i <- dgamma(
  x = plot_sl_i$x,
  shape = 0.3,
  scale = 600
)

# resting
plot_sl_i$r <- dgamma(
  x = plot_sl_i$x,
  shape = 0.1,
  scale = 800
)

# exploratory
plot_sl_i$e <- dgamma(
  x = plot_sl_i$x,
  shape = 0.7,
  scale = 1200
)


# pivot from wide data to long data
plot_sl <- plot_sl_i %>% pivot_longer(cols = -x)
plot_sl


# plot 
ggplot(plot_sl, aes(x = x, y = value, color = factor(name)))+
  geom_line(size = 1)+
  xlab("Step Length (m)")+
  ylab("Probability Density")+
  scale_color_manual(name = "Distribution",
                     breaks = c("ni", "i", "r", "e"),
                     values = c("blue", "orange", "red", "darkgreen"))+
  theme_bw()
```


prep for the simulation 
```{r prep for the simulation}
# covariance matrix for the movement parameters 
sig <- matrix(c(0.4, 0.15, 0.15, 0.15, 0.3, 0.15, 0.15, 0.15, 0.4), ncol = 3, byrow = TRUE)

# parameter values
param.value_n <- data.frame(id = NA, shape = NA, scale = NA, kappa = NA) # non_infected 
param.value_i <- data.frame(id = NA, shape = NA, scale = NA, kappa = NA) # infected

# number of individual
n_ind <- 1 

# Initial start point
start <- make_start(c(runif(1, 350000, 400000), runif(1, 1700000, 1800000)), ta_ = 0)

# number of total steps to generate
total_days <- 30
```


## transitional matrix - infection

prep for the recursive Markov chain manner for getting the infection status (each is per day) and 24 steps per day since it is resampled by hourly. 
```{r infection status generator}
# transitional probability matrix for infection
trans_m1 <- matrix(c(0.9, 0.1, 0.01, 0.99),
              nrow = 2,
              byrow = TRUE)

# Function: ReMC
# Description: This function represents a recursive representation of a Markov chain.
# Parameters:
#   - v: vector representing the initial state of the Markov chain
#   - n: integer representing the number of steps in the Markov chain
# Returns:
#   - A vector representing the state of the Markov chain after n steps

ReMC_i <- function(v, n) {
    # Base case: if n equals 1, return the initial state v
    if (n == 1) return(v)
    
    # Recursive step: compute the state of the Markov chain after n - 1 steps
    p <- ReMC_i(v, n - 1)
    
    # Extract the last element of the computed state vector
    u <- tail(p, 1)
    
    # Select the next state based on the transition matrix trans_m
    # Sample from a binary vector (0, 1) with probabilities determined by the transition matrix
    next_state <- sample(c(0, 1), 1, prob = trans_m1[ifelse(u, 2, 1),])
    
    # Concatenate the computed state vector with the next state
    # This represents the state of the Markov chain after n steps
    c(p, next_state)
}

# initial infection value - start from the non-infected phase  
x0 <- c(infection = 0)

# apply the above function to the list of vector of the initial infection parm val
infection_info <- (sapply(x0, ReMC_i, total_days))

# check the infection_info
infection_info
```

## simulate the paths

The provided code simulates the path of an individual with specified conditions and annotations. It incorporates a transitional probability matrix (tpm) to determine changes in infection status during each step of the simulation. Depending on the current infection status of the individual, the code selects the appropriate probability from the matrix to determine the next state. The simulation iterates through each step, updating the infection status accordingly and simulating the path based on the redistribution kernel.
```{r simulation}
# Create empty lists to store results
ssf_sim <- vector("list", length = total_days)

# Looping for transitions between states
for (ind in 1:n_ind) {
  
  # Model per group
  
  ## model - non infected
  m_n <- make_issf_model(coefs = c("final.shrub_end" = 0.005, 
                                    "sl_" = 0, 
                                    "log(sl_)" = 0, 
                                    "cos(ta_)" = 0, 
                                    "sl_:final.shrub_start" = 0.005, 
                                    "log(sl_):final.shrub_start" = 0.005, 
                                    "cos(ta_):final.shrub_start" = 0.005),
                          sl = make_gamma_distr(shape = 0.5,
                                                scale = 1000),
                          ta = make_vonmises_distr(kappa = 0.15))
  ## model - infected
  m_i <- make_issf_model(coefs = c("final.shrub_end" = 0.01, 
                                    "sl_" = 0, 
                                    "log(sl_)" = 0, 
                                    "cos(ta_)" = 0, 
                                    "sl_:final.shrub_start" = 0.01, 
                                    "log(sl_):final.shrub_start" = 0.01, 
                                    "cos(ta_):final.shrub_start" = 0.01),
                          sl = make_gamma_distr(shape = 0.3,
                                                scale = 600),
                          ta = make_vonmises_distr(kappa = 0.2))

  # Redistribution kernel per group
  
  ## redistribution kernel - non-infected
  rdk_n <- redistribution_kernel(m_n, 
                                  start = start, 
                                  map = shrub, 
                                  landscape = "continuous", 
                                  tolerance.outside = 0.2, 
                                  n.control = 1e4)
  
  ## redistribution kernel - infected
  rdk_i <- redistribution_kernel(m_i, 
                                  start = start, 
                                  map = shrub, 
                                  landscape = "continuous", 
                                  tolerance.outside = 0.2, 
                                  n.control = 1e4)

  # Initialize the start position
  start_position <- start
  
  # Loop for each step
  for (i in 1:total_days) {
    # get the infection status of each day 
    infection <- infection_info[i]
  
    # IF the daily infection status = 0 (non-infected), then generate 24 steps by using rdk_n for 1 step-ahead projections
    if (infection == 0) {
      ssf_sim[[i]] <- data.frame(id = ind, 
                                  infection = infection,
                                  positions = list(simulate_path(rdk_n, n.steps = 24, custom_start = start_position)))  
    } else {
      # IF the daily infection status = 1 (infected), then generate 24 steps by using rdk_i for 1 step-ahead projections
      if (infection == 1) {
        ssf_sim[[i]] <- data.frame(id = ind, 
                                    infection = infection,
                                    positions = list(simulate_path(rdk_i, n.steps = 24, custom_start = start_position)))  
      } 
    }
    # Update the start position for the next iteration
    start_position <- tail(ssf_sim[[i]]$positions, 1)$position
  }
}

# Combine results into one data frame
ssf_df <- do.call(rbind, ssf_sim)
ssf_df <- ssf_df[!duplicated(ssf_df$positions.x_, ssf_df$positions.y_),]

#positions.t <- seq(as.POSIXct("2024-02-05 20:27:26"), as.POSIXct("2024-02-26 16:27:26"), by="hour")
#ssf_df$positions.t_ <- positions.t

ssf_df <- ssf_df %>% mutate(postions.t_ = row_number())
ssf_df

# save the data
#saveRDS(ssf_df, "ssf_sim_trial1.rds")
```

# Visualizations

visualization of the tracks:
```{r trk visualization}
summary(ssf_df)

ssf_df$infection <- as.factor(ssf_df$infection)

ggplot()+
  geom_point(data = ssf_df, aes(positions.x_, positions.y_))+
  facet_wrap(~infection, nrow = 1)


# visualize the movement paths across behaviors
ggplot() + 
  geom_spatraster(data= shrub, show.legend = FALSE) +
  geom_path(data= ssf_df, aes(positions.x_, positions.y_, color= infection), size = 0.1)+
  #scale_colour_gradient(low = "blue", high ="red")+
  #facet_wrap(~infection, nrow = 1)+
  scale_fill_terrain_c() + theme_bw()

dggplot() + 
  geom_spatraster(data= sim_shrub, show.legend = FALSE) +
  geom_path(data= ssf_sim_final, aes(x1_, y1_, color= infection), size = 0.7, alpha = 0.1)+
  scale_colour_gradient(low = "blue", high ="red")+
  #facet_wrap(~infection, nrow = 1)+
  scale_fill_terrain_c() + theme_bw()
```

# Footer
```{r footer}
sessionInfo()
```