---
title: "8.simulations_observed"
author: "Dennis Kim"
date: "2024-01-30"
output: html_document
---

# Document Preamble 
```{r preamble, message=FALSE, warning=FALSE}
# load libraries
library(knitr)
library(readr)
library(data.table)
library(here)
library(purrr)
library(lubridate)
library(scales)
library(conflicted)
library(tidyverse)
library(scico)
library(patchwork)
library(tictoc)

# call environmental data
library(terra)
library(sf)

# analysis
library(amt)
library(MASS)
library(statip)

# visualization 
library(ggplot2)
library(tidyterra)

options(width = 150)

conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflicts_prefer(lubridate::hour)
conflicts_prefer(terra::plot)
conflicts_prefer(dplyr::lag)
```

# shrub layers
```{r shrub layer}
# observed shrub cover
shrub <- terra::rast("D:/Oryx/data/env_data/shrub/final.shrub.tif")
plot(shrub)

sim_shrub <- terra::rast("D:/Oryx/data/env_data/shrub/sim_shrub.tif")
plot(sim_shrub)
```
# simulating tracks using the amt functions 

1. specifying paamters governing the movements for the individual using the *make_issf_model()** function 
2. specifying a redistribution kernel for generating movements based on an initial location and bearing 
3. generating paths from the simulated redistribution kernel specified for a user-provided number of steps 

First call the real dataset to see the reasonable initial values for parameter values per group
```{r observed dataset}
n_oryx <- read_rds(here::here("data/ssf_data", "n_ssf_oryx.rds"))
u_oryx <- read_rds(here::here("data/ssf_data", "u_ssf_oryx.rds"))
i_oryx <- read_rds(here::here("data/ssf_data", "i_ssf_oryx.rds"))

unique(n_oryx$ID) %>% length() # 19 individuals
unique(u_oryx$ID) %>% length() # 25 individuals
unique(i_oryx$ID) %>% length() # 4 individuals
```

# Non-infection periods

```{r tentative params}
# tentative paramters for non infected individuals 

# non-infected individuals
sl_dist_ninf <- fit_distr(n_oryx$sl_, "gamma") # step length
sl_dist_ninf$params$shape
sl_dist_ninf$params$scale
ta_dist_ninf <- fit_distr(n_oryx$ta_, "vonmises") # turn angle
ta_dist_ninf$params$kappa

# infected individuals
sl_dist_inf <- fit_distr(i_oryx$sl_, "gamma") # step length
sl_dist_inf$params$shape
sl_dist_inf$params$scale

ta_dist_inf <- fit_distr(i_oryx$ta_, "vonmises") # turn angle
ta_dist_inf$params$kappa
```
prep for the simulation 
```{r prep for the simulation}
# covariance matrix for the movement parameters 
sig <- matrix(c(0.4, 0.15, 0.15, 0.15, 0.3, 0.15, 0.15, 0.15, 0.4), ncol = 3, byrow = TRUE)

# parameter values
param.value_n <- data.frame(id = NA, shape = NA, scale = NA, kappa = NA) # non_infected 
param.value_i <- data.frame(id = NA, shape = NA, scale = NA, kappa = NA) # infected

# number of individual
n_ind <- 1 

# Initial start point
start <- make_start(c(runif(1, 350000, 400000), runif(1, 1700000, 1800000)), ta_ = 0)
```

prep for the recursive Markov chain manner for getting the infection status (each is per day) and 24 steps per day since it is resampled by hourly. 
```{r infection status generator}
# number of total steps to generate
total_days <- 30

# transitional probability matrix
trans_m <- matrix(c(0.9, 0.1, 0.01, 0.99),
              nrow = 2,
              byrow = TRUE)

# Function: ReMC
# Description: This function represents a recursive representation of a Markov chain.
# Parameters:
#   - v: vector representing the initial state of the Markov chain
#   - n: integer representing the number of steps in the Markov chain
# Returns:
#   - A vector representing the state of the Markov chain after n steps

ReMC <- function(v, n) {
    # Base case: if n equals 1, return the initial state v
    if (n == 1) return(v)
    
    # Recursive step: compute the state of the Markov chain after n - 1 steps
    p <- ReMC(v, n - 1)
    
    # Extract the last element of the computed state vector
    u <- tail(p, 1)
    
    # Select the next state based on the transition matrix trans_m
    # Sample from a binary vector (0, 1) with probabilities determined by the transition matrix
    next_state <- sample(c(0, 1), 1, prob = trans_m[ifelse(u, 2, 1),])
    
    # Concatenate the computed state vector with the next state
    # This represents the state of the Markov chain after n steps
    c(p, next_state)
}

# initial infection value - start from the non-infected phase  
x0 <- c(infection = 0)

# apply the above function to the list of vector of the initial infection parm val
infection_info <- (sapply(x0, ReMC, total_days))

# check the infection_info
infection_info
```

The provided code simulates the path of an individual with specified conditions and annotations. It incorporates a transitional probability matrix (tpm) to determine changes in infection status during each step of the simulation. Depending on the current infection status of the individual, the code selects the appropriate probability from the matrix to determine the next state. The simulation iterates through each step, updating the infection status accordingly and simulating the path based on the redistribution kernel.
```{r simulation}
# Create empty lists to store results
ssf_sim <- vector("list", length = total_days)

# Looping for transitions between states
for (ind in 1:n_ind) {
  
  # Model per group
  
  ## model - non infected
  m_n <- make_issf_model(coefs = c("final.shrub_end" = 0.005, 
                                    "sl_" = 0, 
                                    "log(sl_)" = 0, 
                                    "cos(ta_)" = 0, 
                                    "sl_:final.shrub_start" = 0.005, 
                                    "log(sl_):final.shrub_start" = 0.005, 
                                    "cos(ta_):final.shrub_start" = 0.005),
                          sl = make_gamma_distr(shape = 0.47,
                                                scale = 998),
                          ta = make_vonmises_distr(kappa = 0.156))
  ## model - infected
  m_i <- make_issf_model(coefs = c("final.shrub_end" = 0.01, 
                                    "sl_" = 0, 
                                    "log(sl_)" = 0, 
                                    "cos(ta_)" = 0, 
                                    "sl_:final.shrub_start" = 0.01, 
                                    "log(sl_):final.shrub_start" = 0.01, 
                                    "cos(ta_):final.shrub_start" = 0.01),
                          sl = make_gamma_distr(shape = 0.48,
                                                scale = 573),
                          ta = make_vonmises_distr(kappa = 0.189))

  # Redistribution kernel per group
  
  ## redistribution kernel - non-infected
  rdk_n <- redistribution_kernel(m_n, 
                                  start = start, 
                                  map = shrub, 
                                  landscape = "continuous", 
                                  tolerance = 0.02)
  
  ## redistribution kernel - infected
  rdk_i <- redistribution_kernel(m_i, 
                                  start = start, 
                                  map = shrub, 
                                  landscape = "continuous", 
                                  tolerance = 0.02)

  # Initialize the start position
  start_position <- start
  
  # Loop for each step
  for (i in 1:total_days) {
    # get the infection status of each day 
    infection <- infection_info[i]
  
    # IF the daily infection status = 0 (non-infected), then generate 24 steps by using rdk_n for 1 step-ahead projections
    if (infection == 0) {
      ssf_sim[[i]] <- data.frame(id = ind, 
                                  infection = infection,
                                  positions = list(simulate_path(rdk_n, n.steps = 24, custom_start = start_position)))  
    } else {
      # IF the daily infection status = 1 (infected), then generate 24 steps by using rdk_i for 1 step-ahead projections
      if (infection == 1) {
        ssf_sim[[i]] <- data.frame(id = ind, 
                                    infection = infection,
                                    positions = list(simulate_path(rdk_i, n.steps = 24, custom_start = start_position)))  
      } 
    }
    # Update the start position for the next iteration
    start_position <- tail(ssf_sim[[i]]$positions, 1)$position
  }
}

# Combine results into one data frame
ssf_df <- do.call(rbind, ssf_sim)
ssf_df <- ssf_df[!duplicated(ssf_df$positions.x_, ssf_df$positions.y_),]

#positions.t <- seq(as.POSIXct("2024-02-05 20:27:26"), as.POSIXct("2024-02-26 16:27:26"), by="hour")
#ssf_df$positions.t_ <- positions.t

ssf_df <- ssf_df %>% mutate(postions.t_ = row_number())
ssf_df

# save the data
saveRDS(ssf_df, "ssf_sim_trial1.rds")
```

# Visualizations

visualization of the tracks:
```{r trk visualization}
summary(ssf_df)

ssf_df$infection <- as.factor(ssf_df$infection)

ggplot()+
  geom_point(data = ssf_df, aes(positions.x_, positions.y_))+
  facet_wrap(~infection, nrow = 1)


# visualize the movement paths across behaviors
ggplot() + 
  geom_spatraster(data= shrub, show.legend = FALSE) +
  geom_path(data= ssf_df, aes(positions.x_, positions.y_, color= infection), size = 0.1)+
  #scale_colour_gradient(low = "blue", high ="red")+
  #facet_wrap(~infection, nrow = 1)+
  scale_fill_terrain_c() + theme_bw()

dggplot() + 
  geom_spatraster(data= sim_shrub, show.legend = FALSE) +
  geom_path(data= ssf_sim_final, aes(x1_, y1_, color= infection), size = 0.7, alpha = 0.1)+
  scale_colour_gradient(low = "blue", high ="red")+
  #facet_wrap(~infection, nrow = 1)+
  scale_fill_terrain_c() + theme_bw()
```

# Footer
```{r footer}
sessionInfo()
```