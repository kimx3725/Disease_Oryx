---
title: "6.simulation_5x5states"
author: "Dennis Kim"
date: "2024-01-30"
output: html_document
---

# Document Preamble 
```{r preamble, message=FALSE, warning=FALSE}
# load libraries
library(knitr)
library(readr)
library(data.table)
library(here)
library(purrr)
library(lubridate)
library(scales)
library(conflicted)
library(tidyverse)
library(scico)
library(patchwork)
library(tictoc)

# call environmental data
library(terra)
library(sf)

# analysis
library(amt)
library(MASS)
library(statip)
library(ConnMatTools)

# visualization 
library(ggplot2)
library(tidyterra)

options(width = 150)

conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflicts_prefer(lubridate::hour)
conflicts_prefer(terra::plot)
conflicts_prefer(dplyr::lag)
conflicts_prefer(terra::extract)
```

# simulating tracks using the amt functions 

1. specifying paamters governing the movements for the individual using the *make_issf_model()** function 
2. specifying a redistribution kernel for generating movements based on an initial location and bearing 
3. generating paths from the simulated redistribution kernel specified for a user-provided number of steps 

First call the real dataset to see the reasonable initial values for parameter values per group
```{r observed dataset}
hmm <- readr::read_rds(here::here("data/HMM_outputs", "hmm_m2_output.rds"))

# extracting step lenght and turn angle distribution per each state 

# step length
meanNE <- hmm$mle$step[1,1]
sdNE <- hmm$mle$step[2,1]

meanNR <- hmm$mle$step[1,2]
sdNR <- hmm$mle$step[2,2]  

meanIE <- hmm$mle$step[1,3]
sdIE <- hmm$mle$step[2,3]  

meanIR <- hmm$mle$step[1,4] 
sdIR <- hmm$mle$step[2,4]

meanD <- hmm$mle$step[1,5]
sdD <- hmm$mle$step[2,5]

# Use gammaParamsConvert function to calculate shape and scale parameters
NE_params <- gammaParamsConvert(mean = meanNE, sd = sdNE)
NR_params <- gammaParamsConvert(mean = meanNR, sd = sdNR)
IE_params <- gammaParamsConvert(mean = meanIE, sd = sdIE)
IR_params <- gammaParamsConvert(mean = meanIR, sd = sdIR)
D_params <- gammaParamsConvert(mean = meanD, sd = sdD)

hmm$mle$angle
NE_params
NR_params
IE_params
IR_params
D_params
```

```{r plot gamma}
# plot gamma distribution
x <- (1:1000)/100000
y1 <- dgamma(x = x, shape = 3.3, 600) # NE
y2 <- dgamma(x = x, shape = 0.3, 660) # NR
y3 <- dgamma(x = x, shape = 0.75, 550) # IE
y4 <- dgamma(x = x, shape = 0.15, 50) # IR
y5 <- dgamma(x = x, shape = 0.6, 16) # D

df <- data.frame(x = rep(x, 5),
                 y = c(y1, y2, y3, y4, y5),
                 group = factor(rep(1:5, each = length(x))))

ggplot(df, aes(x = x, y = y, color = group)) +
  geom_line(size = 1) +
  scale_color_manual(values = c("black", "red", "green", "blue", "orange")) +
  labs(color = "Gamma Distribution") +
  theme_minimal() +
  theme(legend.position = "topright") +
  guides(color = guide_legend(title = "Gamma Functions", ncol = 1))
```


# shrub layers
```{r shrub layer}
# observed shrub cover
shrub <- terra::rast("D:/Oryx/data/env_data/shrub/cropped_shrub.tif")
#shrub
#plot(shrub)
```

prep for the simulation 
```{r prep for the simulation}
# covariance matrix for the movement parameters 
sig <- matrix(c(0.4, 0.15, 0.15, 0.15, 0.3, 0.15, 0.15, 0.15, 0.4), ncol = 3, byrow = TRUE)

# parameter values
param.value_n <- data.frame(id = NA, shape = NA, scale = NA, kappa = NA) # non_infected 
param.value_i <- data.frame(id = NA, shape = NA, scale = NA, kappa = NA) # infected

# number of individual
n_ind <- 10

# Initial start point
start <- make_start(c(runif(1, 359000, 360000), runif(1, 1690000, 1700000)), ta_ = 0)

# number of total steps to generate = the average time across 30 individuals
total_days <- 28

# shrub cover threshold 
threshold <- 5
```

## transitional matrix - infection x behavioral states 

transitional matrix
```{r transitional matrix}
## transitional matrix - infection x behavioral states 
# Define transitional probability matrices based on current and previous shrub cover conditions
trans_m_high <- matrix(c(
  0.3, 0.7, 0, 0, 0,
  0.0499, 0.6, 0, 0.35, 0.0001,
  0, 0, 0.2, 0.8, 0,
  0, 0, 0.05, 0.6, 0.35,
  0, 0, 0, 0, 1
), nrow = 5, ncol = 5, byrow = TRUE)

trans_m_low <- matrix(c(
  0.7, 0.3, 0, 0, 0,
  0.2499, 0.5, 0, 0.25, 0.0001,
  0, 0, 0.3, 0.7, 0,
  0, 0, 0.2, 0.5, 0.3,
  0, 0, 0, 0, 1
), nrow = 5, ncol = 5, byrow = TRUE)
```

## iSSF model
Define the iSSF model
```{r iSSF models}
## model 1 - non-infected & exploratory
  m_ne <- make_issf_model(coefs = c("final.shrub_end" = 0, 
                                    "sl_" = 0, 
                                    "log(sl_)" = 0, 
                                    "cos(ta_)" = 0, 
                                    "sl_:final.shrub_start" = 0, 
                                    "log(sl_):final.shrub_start" = 0, 
                                    "cos(ta_):final.shrub_start" = 0),
                          sl = make_gamma_distr(shape = 3.3,
                                                scale = 600),
                          ta = make_vonmises_distr(kappa = 0.09))
  
## model 2 - non infected & resting
  m_nr <- make_issf_model(coefs = c("final.shrub_end" = 0, 
                                    "sl_" = 0, 
                                    "log(sl_)" = 0, 
                                    "cos(ta_)" = 0, 
                                    "sl_:final.shrub_start" = 0, 
                                    "log(sl_):final.shrub_start" = 0, 
                                    "cos(ta_):final.shrub_start" = 0),
                          sl = make_gamma_distr(shape = 0.3,
                                                scale = 660),
                          ta = make_vonmises_distr(kappa = 0.0001))
  
## model 3 - infected & exploratory
  m_ie <- make_issf_model(coefs = c("final.shrub_end" = 0, 
                                    "sl_" = 0, 
                                    "log(sl_)" = 0, 
                                    "cos(ta_)" = 0, 
                                    "sl_:final.shrub_start" = 0, 
                                    "log(sl_):final.shrub_start" = 0, 
                                    "cos(ta_):final.shrub_start" = 0),
                          sl = make_gamma_distr(shape = 0.75,
                                                scale = 550),
                          ta = make_vonmises_distr(kappa = 0.06))
  
## model 4 - infected & resting
  m_ir <- make_issf_model(coefs = c("final.shrub_end" = 0, 
                                    "sl_" = 0, 
                                    "log(sl_)" = 0, 
                                    "cos(ta_)" = 0, 
                                    "sl_:final.shrub_start" = 0, 
                                    "log(sl_):final.shrub_start" = 0, 
                                    "cos(ta_):final.shrub_start" = 0),
                          sl = make_gamma_distr(shape = 0.15,
                                                scale = 50),
                          ta = make_vonmises_distr(kappa = 0.0001))
  
## model 5 - death 
  m_d <- make_issf_model(coefs = c("final.shrub_end" = 0, 
                                    "sl_" = 0, 
                                    "log(sl_)" = 0, 
                                    "cos(ta_)" = 0, 
                                    "sl_:final.shrub_start" = 0, 
                                    "log(sl_):final.shrub_start" = 0, 
                                    "cos(ta_):final.shrub_start" = 0),
                          sl = make_gamma_distr(shape = 0.6,
                                                scale = 16),
                          ta = make_vonmises_distr(kappa =0.001))
  
# Redistribution kernel per group
  
  ## redistribution kernel - non-infected explore
  rdk_ne <- redistribution_kernel(m_ne, 
                                  start = start, 
                                  map = shrub, 
                                  landscape = "continuous", 
                                  tolerance = 0.02)
  
  ## redistribution kernel - non-infected resting
  rdk_nr <- redistribution_kernel(m_nr, 
                                  start = start, 
                                  map = shrub, 
                                  landscape = "continuous", 
                                  tolerance = 0.02)
  
  ## redistribution kernel - infected exploratory
  rdk_ie <- redistribution_kernel(m_ie, 
                                  start = start, 
                                  map = shrub, 
                                  landscape = "continuous", 
                                  tolerance = 0.02)
  
  ## redistribution kernel - infected resting
  rdk_ir <- redistribution_kernel(m_ir, 
                                  start = start, 
                                  map = shrub, 
                                  landscape = "continuous", 
                                  tolerance = 0.02)
  
  ## redistirubtion kernel - death 
  rdk_d <- redistribution_kernel(m_d, 
                                  start = start, 
                                  map = shrub, 
                                  landscape = "continuous", 
                                  tolerance = 0.02)
```


## simulate the paths

The provided code simulates the path of an individual with specified conditions and annotations. It incorporates a transitional probability matrix (tpm) to determine changes in infection status during each step of the simulation. Depending on the current infection status of the individual, the code selects the appropriate probability from the matrix to determine the next state. The simulation iterates through each step, updating the infection status accordingly and simulating the path based on the redistribution kernel.
```{r simulation}
# Create empty lists to store results
ssf_sim <- vector("list", length = total_days)
ind_sim <- vector("list", length = n_ind)

# Looping for transitions between states
for (ind in 1:n_ind) {
  
  # Initialize the start position as a vector with x and y coordinates
  start_position <- start  # Ensure 'start' has 'x_' and 'y_' fields
  
  # Loop for each day
  for (i in 1:total_days) {
    
    if (i == 1) {
      
      # If it's the first day, assume the individual is in state 1 (non-infected explore)
      state <- 1
      
      # Generate the path for the initial state
      path <- simulate_path(rdk_ne, n.steps = 24, custom_start = start_position)
    } else {
      
      # Extract the last position from the previous day
      last_position <- tail(path, 1)
      last_position <- last_position %>% dplyr::select(x_, y_)

      # Extract the shrub cover value at the end of the previous day's path
      shrub_cover <- extract(shrub, last_position)
      shrub_cover <- shrub_cover %>% dplyr::select(final.shrub)
      
      # Handle potential NA values or take the first element if multiple values are returned
      shrub_cover <- ifelse(is.na(shrub_cover), 0, shrub_cover[1])
      
      # Select the appropriate transitional probability matrix based on current shrub cover condition
      if (shrub_cover > threshold) {
        trans_m <- trans_m_high
      } else {
        trans_m <- trans_m_low
      }
      
      # Get the next day's infection status based on the previous state
      state <- sample(1:5, 1, prob = trans_m[state, ])
      
      # Generate the path for the next day based on the updated state
      path <- switch(state,
                     `1` = simulate_path(rdk_ne, n.steps = 24, custom_start = start_position),
                     `2` = simulate_path(rdk_nr, n.steps = 24, custom_start = start_position),
                     `3` = simulate_path(rdk_ie, n.steps = 24, custom_start = start_position),
                     `4` = simulate_path(rdk_ir, n.steps = 24, custom_start = start_position),
                     `5` = simulate_path(rdk_d, n.steps = 24, custom_start = start_position))
    }
    
    # Store the simulated path
    ssf_sim[[i]] <- data.frame(id = ind, state = state, positions = I(list(path)))
    
    # Update the start position for the next iteration to the last point of the current path
    start_position <- c(x = tail(path$x_, 1), y = tail(path$y_, 1))
  }
  
  # Store the simulated paths for the individual
  ind_sim[[ind]] <- ssf_sim
}
    
# Flatten the nested list
flat_list <- unlist(ind_sim, recursive = FALSE)

# Convert the flattened list to a dataframe
ssf_df <- do.call(rbind, lapply(flat_list, as.data.frame))

ssf_df <- unnest(ssf_df, positions)
ssf_df

# save the data
#saveRDS(ssf_df, here::here("data/simulation_data", "sim2_trk_10ids_3.rds"))
```

# Visualizations

visualization of the tracks:
```{r trk visualization}
# prep for sff_df
ssf_df$state <- as.factor(ssf_df$state)

# change the labels
state_names <- c('1' = "NE", '2' = "NR", '3' = "IE", '4' = "IR", '5' = "D")

ggplot()+
  geom_point(data = ssf_df, aes(x_, y_))+
  facet_wrap(~state, 
             nrow = 1,
             labeller = labeller(state = state_names))


# visualize the movement paths across behaviors
p <- ggplot()+
  geom_spatraster(data = shrub, show.legend = FALSE)+
  geom_point(data = ssf_df, aes(x_, y_), size = 0.7)+
  labs(title = "Oryx simulation with 5 different states")+
  facet_wrap(~state,
             labeller = labeller(state = state_names),
             nrow = 1)+
  scale_fill_terrain_c()+
  theme_bw()+
  xlab("Eastings")+
  ylab("Northings")

p + theme(axis.text.x=element_text(angle=45, hjust=1))
```

# Footer
```{r footer}
sessionInfo()
```